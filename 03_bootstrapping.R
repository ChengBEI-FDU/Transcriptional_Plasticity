#### Import packages ####
library(openxlsx)
library(tidyverse)
library(edgeR)
library(limma)
library(vegan)
library(moments)
library(ggplot2)
library(rtracklayer)
library(mclust)
library(ggpubr)
library(sva)
library(ggstream)
library(reshape2)
library(ggsci)


#### Functions ####
# sd and mean
calculating_SD_Mean <- function(expr, # RPKM that has been filtered by SI and 0-expr proportion
                                log = T
) {
  # whether log expression data
  if (log) {expr <- log2(expr+1)}
  
  # SD, mean, median of log2(RPKM+1)
  expr.sd.logRPKM <- apply(expr, 1, sd)
  expr.mean.logRPKM <- apply(expr, 1, mean)
  
  # MERGE
  gene.sd_mean <- data.frame(gene = rownames(expr),
                             SD_logRPKM = expr.sd.logRPKM, 
                             Mean_logRPKM = expr.mean.logRPKM)
  
  return(gene.sd_mean)
}

# Min-Max
calculating_MinMax <- function(expr, # RPKM that has been filtered by SI and 0-expr proportion
                               log = T
) {
  # whether log expression data
  if (log) {expr <- log2(expr+1)}
  
  # min, max
  expr.min <- apply(expr, 1, min)
  expr.max <- apply(expr, 1, max)
  expr.MinMax <- expr.max - expr.min
  
  # MERGE
  gene.MinMax <- data.frame(gene = rownames(expr),
                            MinExpr = expr.min, 
                            MaxExpr = expr.max,
                            MinMax = expr.MinMax)
  
  return(gene.MinMax)
}

# Min-Max and IQR
calculating_MinMax_IQR <- function(expr, # RPKM that has been filtered by SI and 0-expr proportion
                                   log = T
) {
  # whether log expression data
  if (log) {expr <- log2(expr+1)}
  
  # min, max
  expr.min <- apply(expr, 1, min)
  expr.max <- apply(expr, 1, max)
  expr.MinMax <- expr.max - expr.min
  
  # IQR
  expr.q25.logRPKM <- apply(expr, 1, function(x) {quantile(x,0.25)})
  expr.q75.logRPKM <- apply(expr, 1, function(x) {quantile(x,0.75)})
  expr.IQR.logRPKM <- expr.q75.logRPKM - expr.q25.logRPKM
  
  # MERGE
  gene.MinMax_IQR <- data.frame(gene = rownames(expr),
                                MinExpr = expr.min, 
                                MaxExpr = expr.max,
                                MinMax = expr.MinMax,
                                IQR_logRPKM = expr.IQR.logRPKM)
  
  return(gene.MinMax_IQR)
}

# TP calculate from sd and mean
calculating_TP <- function(SD_Mean_data, #  generated by FUNCTION "calculating_SD_Mean"
                           loess_span = 0.7,
                           loess_degree = 1
) {
  ExprAnnotation <- SD_Mean_data
  loess.model <- loess(SD_logRPKM ~ Mean_logRPKM, data = ExprAnnotation, span = loess_span, degree = loess_degree)
  ExprAnnotation$residual.SD_logRPKM <- loess.model$residuals
  ExprAnnotation$LOESS.fit <- loess.model$fitted
  ExprAnnotation$TP <- ExprAnnotation$residual.SD_logRPKM + mean(ExprAnnotation$LOESS.fit)
  
  return(ExprAnnotation)
}

# Bootstrap for TP
Bootstrap_TP <- function(filtered_expr, # RPKM that has been filtered by SI and 0-expr proportion
                         split_sample_count, # a vector contains each size of sample subgroups
                         set_seed = 2022,
                         repeat_time = 30 # repeat time of calculating TP for each sample subgroup
) {
  
  # calculate TP from total samples
  SD_Mean.total <- calculating_SD_Mean(filtered_expr)
  TP.total <- calculating_TP(SD_Mean.total)
  TP.total <- data.frame(gene = TP.total$gene, TP = TP.total$TP)
  
  # split samples into subgroups
  BootSize <- data.frame(sample = split_sample_count, size = split_sample_count)
  sample.Run <- colnames(filtered_expr)
  CorTPSampling <- as.data.frame(matrix(nrow = repeat_time, ncol = length(split_sample_count)))
  colnames(CorTPSampling) <- split_sample_count
  
  # calculate pearson cor between TP from total sample with TP from sample subgroup
  set.seed(set_seed)
  for (j in 1:length(split_sample_count)) {
    temp.size = BootSize$size[j]
    for(i in 1:repeat_time) {
      temp.boot <- replicate(repeat_time, expr = {sample(sample.Run, size = temp.size)})
      temp.expr <- filtered_expr[,colnames(filtered_expr) %in% temp.boot[,i]]
      temp.SD_Mean <- calculating_SD_Mean(temp.expr)
      temp.TP <- calculating_TP(temp.SD_Mean)
      temp.TP.info <- data.frame(gene = temp.TP$gene, TP_sub = temp.TP$TP)
      temp.TP.info <- merge(temp.TP.info, TP.total, by = 'gene')
      CorTPSampling[i,j] <- cor(x = temp.TP.info$TP_sub, y = temp.TP.info$TP, method="pearson")
    }
  }
  
  return(CorTPSampling)
}

# Bootstrap for Min-Max
Bootstrap_MinMax <- function(filtered_expr, # RPKM that has been filtered by SI and 0-expr proportion
                             split_sample_count, # a vector contains each size of sample subgroups
                             set_seed = 2022,
                             repeat_time = 30 # repeat time of calculating TP for each sample subgroup
) {
  
  # calculate TP from total samples
  MinMax.total <- calculating_MinMax(filtered_expr)
  MinMax.total <- data.frame(gene = MinMax.total$gene, MinMax = MinMax.total$MinMax)
  
  # split samples into subgroups
  BootSize <- data.frame(sample = split_sample_count, size = split_sample_count)
  sample.Run <- colnames(filtered_expr)
  CorMinMaxSampling <- as.data.frame(matrix(nrow = repeat_time, ncol = length(split_sample_count)))
  colnames(CorMinMaxSampling) <- split_sample_count
  
  # calculate pearson cor between TP from total sample with TP from sample subgroup
  set.seed(set_seed)
  for (j in 1:length(split_sample_count)) {
    temp.size = BootSize$size[j]
    for(i in 1:repeat_time) {
      temp.boot <- replicate(repeat_time, expr = {sample(sample.Run, size = temp.size)})
      temp.expr <- filtered_expr[,colnames(filtered_expr) %in% temp.boot[,i]]
      temp.MinMax <- calculating_MinMax(temp.expr)
      temp.MinMax.info <- data.frame(gene = temp.MinMax$gene, MinMax_sub = temp.MinMax$MinMax)
      temp.MinMax.info <- merge(temp.MinMax.info, MinMax.total, by = 'gene')
      CorMinMaxSampling[i,j] <- cor(x = temp.MinMax.info$MinMax_sub, y = temp.MinMax.info$MinMax, method="pearson")
    }
  }
  
  return(CorMinMaxSampling)
}

# Bootstrap for IQR
Bootstrap_IQR <- function(filtered_expr, # RPKM that has been filtered by SI and 0-expr proportion
                          split_sample_count, # a vector contains each size of sample subgroups
                          set_seed = 2022,
                          repeat_time = 30 # repeat time of calculating TP for each sample subgroup
) {
  
  # calculate TP from total samples
  IQR.total <- calculating_MinMax_IQR(filtered_expr)
  IQR.total <- data.frame(gene = IQR.total$gene, IQR = IQR.total$IQR_logRPKM)
  
  # split samples into subgroups
  BootSize <- data.frame(sample = split_sample_count, size = split_sample_count)
  sample.Run <- colnames(filtered_expr)
  CorIQRSampling <- as.data.frame(matrix(nrow = repeat_time, ncol = length(split_sample_count)))
  colnames(CorIQRSampling) <- split_sample_count
  
  # calculate pearson cor between TP from total sample with TP from sample subgroup
  set.seed(set_seed)
  for (j in 1:length(split_sample_count)) {
    temp.size = BootSize$size[j]
    for(i in 1:repeat_time) {
      temp.boot <- replicate(repeat_time, expr = {sample(sample.Run, size = temp.size)})
      temp.expr <- filtered_expr[,colnames(filtered_expr) %in% temp.boot[,i]]
      temp.IQR <- calculating_MinMax_IQR(temp.expr)
      temp.IQR.info <- data.frame(gene = temp.IQR$gene, IQR_sub = temp.IQR$IQR_logRPKM)
      temp.IQR.info <- merge(temp.IQR.info, IQR.total, by = 'gene')
      CorIQRSampling[i,j] <- cor(x = temp.IQR.info$IQR_sub, y = temp.IQR.info$IQR, method="pearson")
    }
  }
  
  return(CorIQRSampling)
}


#### Input data ####
rpkm_mtb <- read.csv("./data/RPKM Mtb.csv", row.names = 1)
rpkm_msm <- read.csv("./data/RPKM Msm.csv", row.names = 1)
rpkm_mab <- read.csv("./data/RPKM Mab.csv", row.names = 1)


#### Bootstrap TP ####
# Mtb
ptm <- proc.time()
Bootstrap_Mtb <- Bootstrap_TP(filtered_expr = rpkm_mtb, 
                              split_sample_count = c(10,20,30,50,100,200,300,500,800,894),
                              set_seed = 2022,
                              repeat_time = 30)
proc.time() - ptm
write.csv(Bootstrap_Mtb, "./data/bootstrap_TP Mtb.csv")

# Msm
ptm <- proc.time()
Bootstrap_Msmeg <- Bootstrap_TP(filtered_expr = rpkm_msm, 
                                split_sample_count = c(10,20,30,50,80,120,150,192),
                                set_seed = 2022,
                                repeat_time = 30)
proc.time() - ptm
write.csv(Bootstrap_Msmeg, "./data/bootstrap_TP Msmeg.csv")

# Mab
ptm <- proc.time()
Bootstrap_Mab <- Bootstrap_TP(filtered_expr = rpkm_mab, 
                              split_sample_count = c(10,20,30,50,80,106),
                              set_seed = 2022,
                              repeat_time = 30)
proc.time() - ptm
write.csv(Bootstrap_Mab, "./data/bootstrap_TP Mab.csv")


#### Bootstrap MinMax ####
# Mtb
ptm <- proc.time()
Bootstrap_MM_Mtb <- Bootstrap_MinMax(filtered_expr = rpkm_mtb, 
                                     split_sample_count = c(10,20,30,50,100,200,300,500,800,894),
                                     set_seed = 2022,
                                     repeat_time = 30)
proc.time() - ptm
write.csv(Bootstrap_MM_Mtb, "./data/bootstrap_MinMax Mtb.csv")


# Msm
ptm <- proc.time()
Bootstrap_MM_Msmeg <- Bootstrap_MinMax(filtered_expr = rpkm_msm, 
                                       split_sample_count = c(10,20,30,50,80,120,150,192),
                                       set_seed = 2022,
                                       repeat_time = 30)
proc.time() - ptm
write.csv(Bootstrap_MM_Msmeg, "./data/bootstrap_MinMax Msmeg.csv")

# Mab
ptm <- proc.time()
Bootstrap_MM_Mab <- Bootstrap_MinMax(filtered_expr = rpkm_mab, 
                                     split_sample_count = c(10,20,30,50,80,106),
                                     set_seed = 2022,
                                     repeat_time = 30)
proc.time() - ptm
write.csv(Bootstrap_MM_Mab, "./data/bootstrap_MinMax Mab.csv")


#### Run Bootstrap for IQR ####
# Mtb
ptm <- proc.time()
Bootstrap_IQR_Mtb <- Bootstrap_IQR(filtered_expr = rpkm_mtb, 
                                   split_sample_count = c(10,20,30,50,100,200,300,500,800,894),
                                   set_seed = 2022,
                                   repeat_time = 30)
proc.time() - ptm
write.csv(Bootstrap_IQR_Mtb, "./data/bootstrap_IQR Mtb.csv")


# Msm
ptm <- proc.time()
Bootstrap_IQR_Msmeg <- Bootstrap_IQR(filtered_expr = rpkm_msm, 
                                     split_sample_count = c(10,20,30,50,80,120,150,192),
                                     set_seed = 2022,
                                     repeat_time = 30)
proc.time() - ptm
write.csv(Bootstrap_IQR_Msmeg, "./data/bootstrap_IQR Msmeg.csv")

# Mab
ptm <- proc.time()
Bootstrap_IQR_Mab <- Bootstrap_IQR(filtered_expr = rpkm_mab, 
                                   split_sample_count = c(10,20,30,50,80,106),
                                   set_seed = 2022,
                                   repeat_time = 30)
proc.time() - ptm
write.csv(Bootstrap_IQR_Mab, "./data/bootstrap_IQR Mab.csv")


#### Bootstrap for high-TP genes (Fig. S1) ####
# input
rpkm_mtb <- read.csv("./data/RPKM Mtb.csv", row.names = 1)
TP_Mtb_group <- read.csv("data/TP Mtb.csv")
TP_Mtb_group$TP_group <- 'other'
TP_Mtb_group$TP_group[TP_Mtb_group$TP > quantile(TP_Mtb_group$TP, 0.95)] <- 'top_5_percent'

# function
Bootstrap_TP_for_each_gene <- function(filtered_expr, # RPKM that has been filtered by SI and 0-expr proportion
                                       split_sample_count, # a vector contains each size of sample subgroups
                                       set_seed = 2022,
                                       repeat_time = 1 # repeat time of calculating TP for each sample subgroup
) {
  
  # calculate TP from total samples
  SD_Mean.total <- calculating_SD_Mean(filtered_expr)
  TP.total <- calculating_TP(SD_Mean.total)
  TP.total <- data.frame(gene = TP.total$gene, TP = TP.total$TP)
  
  # split samples into subgroups
  BootSize <- data.frame(sample = split_sample_count, size = split_sample_count)
  sample.Run <- colnames(filtered_expr)
  TP_each_gene <- data.frame(gene = rownames(filtered_expr))
  
  # calculate pearson cor between TP from total sample with TP from sample subgroup
  set.seed(set_seed)
  for (j in 1:length(split_sample_count)) {
    temp.size = BootSize$size[j]
    for(i in 1:repeat_time) {
      temp.boot <- replicate(repeat_time, expr = {sample(sample.Run, size = temp.size)})
      temp.expr <- filtered_expr[,colnames(filtered_expr) %in% temp.boot[,i]]
      temp.SD_Mean <- calculating_SD_Mean(temp.expr)
      temp.TP <- calculating_TP(temp.SD_Mean)
      temp.TP.info <- data.frame(gene = temp.TP$gene, TP_sub = temp.TP$TP)
    }
    colnames(temp.TP.info)[2] <- temp.size
    TP_each_gene <- merge(TP_each_gene, temp.TP.info, by = 'gene', all.x = T)
  }
  return(TP_each_gene)
}

# run
split_sample_count = c(10,30,100,300)
bootstrap_res <- data.frame()

ptm <- proc.time()
for (i in 1:100) {
  cat(paste0(i,"%",collapse = ""))
  cat('\r')
  set_seed <- i
  tmp <- Bootstrap_TP_for_each_gene(filtered_expr = rpkm_mtb, 
                                    split_sample_count = split_sample_count,
                                    set_seed = set_seed,
                                    repeat_time = 1)
  tmp$seed <- set_seed
  bootstrap_res <- rbind(bootstrap_res,tmp)
}
proc.time() - ptm

bootstrap_res <- merge(bootstrap_res, TP_Mtb_group, by = 'gene', all.x = T)

write.csv(bootstrap_res, './data/bootstrap_TP_highTPgenes.csv')
